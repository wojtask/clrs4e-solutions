As with the binary heap, we can view the $d$-ary heap data structure as a nearly complete $d$-ary tree in which all levels except possibly the lowest are filled.
The nodes of such a tree can be stored in an array, and for that we'll use an array $A[1\subarr n]$ with an attribute \attrib{A}{heap-size}, which determines how many elements of the $d$-ary heap are stored within array $A$.
In such a representation, the valid elements of the $d$-ary heap occupy $A[1\subarr\attrib{A}{heap-size}]$, where $0\le\attrib{A}{heap-size}\le n$.
The root of the tree is $A[1]$, and given the index $i$ of a node, we can compute the indices of its parent and children using the following procedures, which generalize the original \proc{Parent}, \proc{Left}, and \proc{Right}:

\begin{codebox}
\Procname{$\proc{Multiary-Parent}(d,i)$}
\li \Return $\lceil(i-1)/d\rceil$
\end{innercodebox}
\begin{innercodebox}
\Procname{$\proc{Multiary-Child}(d,i,k)$}
\li \Return $d(i-1)+k+1$
\end{codebox}

Both procedures take as inputs the arity $d$ of the heap and the index $i$ of the node, and \proc{Multiary-Child} accepts additional parameter $k$ denoting the number of the child, where $k=1$, 2, \dots, $d$.

One can check that $\proc{Multiary-Parent}(d,\proc{Multiary-Child}(d,i,k))=i$ for all $k=1$, 2, \dots, $d$.
